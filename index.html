<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Mini Angry Birds</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    touch-action: none;
    background: linear-gradient(to top, #87ceeb 0%, #ffffff 100%);
    user-select: none;
  }
  #gameCanvas {
    display: block;
    background: #a3d9ff;
    margin: 0 auto;
    touch-action: none;
  }
  #info {
    position: fixed;
    top: 10px; left: 10px; right: 10px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    font-weight: bold;
    text-align: center;
    z-index: 10;
    user-select: none;
  }
  #levelMessage {
    background: rgba(255 255 255 / 0.8);
    border-radius: 12px;
    padding: 10px 20px;
    margin-bottom: 8px;
    font-size: 20px;
  }
  #restartBtn {
    cursor: pointer;
    background: #ff4136;
    border: none;
    border-radius: 8px;
    color: white;
    padding: 8px 16px;
    font-weight: bold;
    font-size: 16px;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #restartBtn:hover {
    background: #ff6b5f;
  }
</style>
</head>
<body>
<div id="info">
  <div id="levelMessage">Level 1 - Knock down all the pigs üê∑!</div>
  <button id="restartBtn">Restart Level</button>
</div>
<canvas id="gameCanvas" width="375" height="667"></canvas>

<script>
// Mini Angry Birds v1 by Gerald

// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const W = canvas.width;
const H = canvas.height;

// Physics constants
const gravity = 0.8;
const friction = 0.98;

// Game state
let gameState = 'aim'; // 'aim', 'flying', 'reset', 'win'
let currentLevel = 0;
const totalLevels = 3;

const pigRadius = 16;
const birdRadius = 20;
const blockWidth = 40;
const blockHeight = 40;

// Positions
const slingshotX = 80;
const slingshotY = H - 140;

let bird = null;
let blocks = [];
let pigs = [];

let aiming = false;
let aimStart = null;
let aimEnd = null;

let score = 0;

// Utility functions
function dist(x1,y1,x2,y2){
  return Math.hypot(x2 - x1, y2 - y1);
}

function rectCircleColliding(circle, rect){
  // circle: {x,y,r}
  // rect: {x,y,w,h}
  let distX = Math.abs(circle.x - rect.x - rect.w/2);
  let distY = Math.abs(circle.y - rect.y - rect.h/2);

  if (distX > (rect.w/2 + circle.r)) { return false; }
  if (distY > (rect.h/2 + circle.r)) { return false; }

  if (distX <= (rect.w/2)) { return true; }
  if (distY <= (rect.h/2)) { return true; }

  let dx=distX - rect.w/2;
  let dy=distY - rect.h/2;
  return (dx*dx + dy*dy <= (circle.r * circle.r));
}

function rectRectColliding(r1, r2){
  return !(r2.x > r1.x + r1.w ||
           r2.x + r2.w < r1.x ||
           r2.y > r1.y + r1.h ||
           r2.y + r2.h < r1.y);
}

// Classes
class Bird {
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.r = birdRadius;
    this.vx = 0;
    this.vy = 0;
    this.launched = false;
    this.color = '#ff4c4c';
    this.rotation = 0;
  }
  update(){
    if(this.launched){
      this.vy += gravity;
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= friction;
      this.vy *= friction;
      this.rotation = Math.atan2(this.vy, this.vx);
      if(this.y > H + 50 || this.x > W + 50 || this.x < -50){
        gameState = 'reset';
      }
    }
  }
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    // Draw mirrored bird facing left
    ctx.scale(-1, 1);
    // Body
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.ellipse(0, 0, this.r, this.r * 0.75, 0, 0, Math.PI * 2);
    ctx.fill();
    // Eye
    ctx.beginPath();
    ctx.fillStyle = 'white';
    ctx.ellipse(-6, -5, 6, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'black';
    ctx.ellipse(-5, -3, 3, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Beak
    ctx.beginPath();
    ctx.fillStyle = 'orange';
    ctx.moveTo(this.r, 0);
    ctx.lineTo(this.r + 15, -8);
    ctx.lineTo(this.r + 15, 8);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

class Block {
  constructor(x,y,w,h){
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.vx = 0;
    this.vy = 0;
    this.mass = 2;
    this.isStatic = false;
    this.angle = 0;
    this.rotationSpeed = 0;
    this.color = '#8b5e3c';
    this.health = 3;
  }
  update(){
    if(!this.isStatic){
      this.vy += gravity;
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= 0.7;
      this.vy *= 0.7;
      // Simple ground collision
      if(this.y + this.h > H - 50){
        this.y = H - 50 - this.h;
        this.vy = 0;
        this.vx *= 0.3;
      }
      // Rotation
      this.angle += this.rotationSpeed;
      this.rotationSpeed *= 0.7;
    }
  }
  draw(){
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.angle);
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
    ctx.restore();
  }
}

class Pig {
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.r = pigRadius;
    this.alive = true;
    this.color = '#66bb6a';
  }
  draw(){
    if(!this.alive) return;
    // Body
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.ellipse(this.x, this.y, this.r, this.r * 0.85, 0, 0, Math.PI*2);
    ctx.fill();
    // Eyes
    ctx.beginPath();
    ctx.fillStyle = 'white';
    ctx.ellipse(this.x - 7, this.y - 5, 5, 6, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + 7, this.y - 5, 5, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = 'black';
    ctx.ellipse(this.x - 7, this.y - 5, 2, 3, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + 7, this.y - 5, 2, 3, 0, 0, Math.PI*2);
    ctx.fill();
    // Nose
    ctx.beginPath();
    ctx.fillStyle = '#3a7e3c';
    ctx.ellipse(this.x, this.y + 5, 7, 4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#2f6e34';
    ctx.ellipse(this.x - 3, this.y + 5, 2, 2, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + 3, this.y + 5, 2, 2, 0, 0, Math.PI*2);
    ctx.fill();
  }
}

// Level layouts (blocks and pigs)
const levels = [
  // Level 1: Simple blocks with 2 pigs
  {
    blocks: [
      {x: 250, y: H - 90, w: 40, h: 40},
      {x: 290, y: H - 90, w: 40, h: 40},
      {x: 270, y: H - 130, w: 40, h: 40},
    ],
    pigs: [
      {x: 280, y: H - 160},
      {x: 320, y: H - 130},
    ],
  },
  // Level 2: More blocks stacked, 3 pigs
  {
    blocks: [
      {x: 230, y: H - 90, w: 40, h: 40},
      {x: 270, y: H - 90, w: 40, h: 40},
      {x: 310, y: H - 90, w: 40, h: 40},
      {x: 250, y: H - 130, w: 40, h: 40},
      {x: 290, y: H - 130, w: 40, h: 40},
      {x: 270, y: H - 170, w: 40, h: 40},
    ],
    pigs: [
      {x: 260, y: H - 160},
      {x: 320, y: H - 160},
      {x: 280, y: H - 200},
    ],
  },
  // Level 3: Tall tower, 4 pigs
  {
    blocks: [
      {x: 250, y: H - 90, w: 40, h: 40},
      {x: 250, y: H - 130, w: 40, h: 40},
      {x: 250, y: H - 170, w: 40, h: 40},
      {x: 290, y: H - 90, w: 40, h: 40},
      {x: 290, y: H - 130, w: 40, h: 40},
      {x: 330, y: H - 90, w: 40, h: 40},
      {x: 330, y: H - 130, w: 40, h: 40},
      {x: 290, y: H - 170, w: 40, h: 40},
    ],
    pigs: [
      {x: 270, y: H - 210},
      {x: 310, y: H - 210},
      {x: 300, y: H - 250},
      {x: 270, y: H - 150},
    ],
  }
];

// Initialize level
function loadLevel(n){
  bird = new Bird(slingshotX, slingshotY);
  blocks = [];
  pigs = [];
  const lvl = levels[n];
  for(const b of lvl.blocks){
    let block = new Block(b.x, b.y, b.w, b.h);
    blocks.push(block);
  }
  for(const p of lvl.pigs){
    let pig = new Pig(p.x, p.y);
    pigs.push(pig);
  }
  gameState = 'aim';
  score = 0;
  document.getElementById('levelMessage').textContent = `Level ${n+1} - Knock down all the pigs üê∑!`;
}

// Collision detection between bird and blocks
function handleBirdBlockCollisions(){
  for(const block of blocks){
    if(block.isStatic) continue;
    // Circle-Rect collision between bird and block
    if(rectCircleColliding({x:bird.x,y:bird.y,r:bird.r}, block)){
      // Simple collision response: reflect velocity and apply damage
      bird.vx = -bird.vx * 0.6;
      bird.vy = -bird.vy * 0.6;
      block.vx += bird.vx * 0.3;
      block.vy += bird.vy * 0.3;
      block.rotationSpeed += (bird.vx + bird.vy)*0.05;
      block.health -= 1;
      if(block.health <= 0){
        // Remove block by making it static and fading color
        block.isStatic = true;
        block.color = '#65432188';
      }
    }
  }
}

// Collision detection between bird and pigs
function handleBirdPigCollisions(){
  for(const pig of pigs){
    if(!pig.alive) continue;
    let d = dist(bird.x, bird.y, pig.x, pig.y);
    if(d < bird.r + pig.r){
      pig.alive = false;
      score++;
      // Bounce bird slightly
      bird.vx *= 0.7;
      bird.vy *= 0.7;
    }
  }
}

// Collision detection between blocks and pigs (blocks can hit pigs)
function handleBlockPigCollisions(){
  for(const pig of pigs){
    if(!pig.alive) continue;
    for(const block of blocks){
      if(block.isStatic) continue;
      let d = dist(pig.x, pig.y, block.x + block.w/2, block.y + block.h/2);
      if(d < pig.r + Math.max(block.w, block.h)/2){
        // Approximate pig hit
        pig.alive = false;
        score++;
      }
    }
  }
}

// Touch / Mouse Controls
function getPos(evt){
  if(evt.touches) {
    return {x: evt.touches[0].clientX, y: evt.touches[0].clientY};
  } else {
    return {x: evt.clientX, y: evt.clientY};
  }
}

canvas.addEventListener('pointerdown', e=>{
  if(gameState !== 'aim') return;
  let pos = getPos(e);
  let dx = pos.x - bird.x;
  let dy = pos.y - bird.y;
  if(dist(pos.x,pos.y,bird.x,bird.y) < bird.r + 30){
    aiming = true;
    aimStart = {x: bird.x, y: bird.y};
    aimEnd = {x: pos.x, y: pos.y};
  }
});

canvas.addEventListener('pointermove', e=>{
  if(!aiming) return;
  let pos = getPos(e);
  aimEnd = {x: pos.x, y: pos.y};
  // Limit aim distance max 100 px
  let dx = aimEnd.x - aimStart.x;
  let dy = aimEnd.y - aimStart.y;
  let distAim = Math.min(dist(aimStart.x, aimStart.y, aimEnd.x, aimEnd.y), 100);
  let angle = Math.atan2(dy, dx);
  aimEnd.x = aimStart.x + Math.cos(angle) * distAim;
  aimEnd.y = aimStart.y + Math.sin(angle) * distAim;
});

canvas.addEventListener('pointerup', e=>{
  if(!aiming) return;
  aiming = false;
  // Launch bird in opposite direction of pull
  let dx = aimEnd.x - aimStart.x;
  let dy = aimEnd.y - aimStart.y;
  bird.vx = -dx * 0.15;
  bird.vy = -dy * 0.15;
  bird.launched = true;
  gameState = 'flying';
});

document.getElementById('restartBtn').onclick = () => {
  loadLevel(currentLevel);
};

// Game loop
function update(){
  if(gameState === 'flying'){
    bird.update();

    for(const block of blocks){
      block.update();
    }

    handleBirdBlockCollisions();
    handleBirdPigCollisions();
    handleBlockPigCollisions();

    // Check win condition: all pigs dead
    if(pigs.every(p => !p.alive)){
      gameState = 'win';
      setTimeout(() => {
        currentLevel++;
        if(currentLevel >= totalLevels){
          alert('Congrats! You beat all levels! üéâ');
          currentLevel = 0;
        }
        loadLevel(currentLevel);
      }, 1000);
    }

    // If bird stopped or out of bounds, reset
    if(gameState === 'flying' && 
      (Math.abs(bird.vx) < 0.1 && Math.abs(bird.vy) < 0.1 || 
       bird.x < -50 || bird.x > W + 50 || bird.y > H + 50)){
      gameState = 'reset';
    }
  } else if(gameState === 'reset'){
    loadLevel(currentLevel);
  }
}

function drawSlingshot(){
  ctx.lineWidth = 6;
  ctx.strokeStyle = '#553311';
  ctx.beginPath();
  ctx.moveTo(slingshotX - 20, slingshotY + 40);
  ctx.lineTo(slingshotX + 20, slingshotY + 40);
  ctx.stroke();
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(slingshotX, slingshotY);
  ctx.lineTo(slingshotX - 15, slingshotY + 40);
  ctx.lineTo(slingshotX + 15, slingshotY + 40);
  ctx.closePath();
  ctx.fillStyle = '#663300';
  ctx.fill();
}

function drawAimLine(){
  if(!aiming) return;
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
  ctx.beginPath();
  ctx.moveTo(bird.x, bird.y);
  ctx.lineTo(aimEnd.x, aimEnd.y);
  ctx.stroke();
}

// Main draw function
function draw(){
  // Clear
  ctx.clearRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#4CAF50';
  ctx.fillRect(0, H - 50, W, 50);

  // Slingshot
  drawSlingshot();

  // Blocks
  for(const block of blocks){
    block.draw();
  }

  // Pigs
  for(const pig of pigs){
    pig.draw();
  }

  // Bird
  bird.draw();

  // Aim line
  drawAimLine();

  // Instructions
  if(gameState === 'aim'){
    ctx.fillStyle = '#222';
    ctx.font = '16px Segoe UI, sans-serif';
    ctx.fillText('Drag the bird and release to shoot!', 50, H - 10);
  }
}

// Main loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

// Start game
loadLevel(currentLevel);
loop();

</script>
</body>
</html>
