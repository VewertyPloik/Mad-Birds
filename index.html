<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Mini Angry Birds - Level Completed Screen</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      background: linear-gradient(to top, #87ceeb 0%, #e0f7fa 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #a3d9ff;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      touch-action: none;
    }
    #ui {
      position: fixed;
      top: 10px; left: 10px; right: 10px;
      text-align: center;
      color: #222;
      font-weight: 700;
      z-index: 10;
      user-select: none;
    }
    #restartBtn {
      background: #ff4136;
      border: none;
      border-radius: 10px;
      padding: 10px 20px;
      color: white;
      font-weight: 700;
      font-size: 18px;
      cursor: pointer;
      margin-top: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.25);
      transition: background-color 0.3s ease;
    }
    #restartBtn:hover {
      background: #ff6b5f;
    }

    #levelCompleteOverlay {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      font-size: 32px;
      font-weight: 700;
      user-select: none;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    #levelCompleteOverlay.visible {
      visibility: visible;
      opacity: 1;
    }
    #nextLevelBtn {
      margin-top: 20px;
      background: #28a745;
      border: none;
      border-radius: 10px;
      padding: 14px 32px;
      color: white;
      font-weight: 700;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
    }
    #nextLevelBtn:hover {
      background: #3cd063;
    }
  </style>
</head>
<body>

<div id="ui">
  <div id="levelText">Level 1: Knock down all pigs üê∑!</div>
  <div id="chancesText">Chances left: 3</div>
  <button id="restartBtn">Restart Level</button>
</div>

<canvas id="gameCanvas" width="375" height="667"></canvas>

<div id="levelCompleteOverlay">
  <div>Level Completed! üéâ</div>
  <button id="nextLevelBtn">Next Level</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const gravity = 0.8;
  const friction = 0.98;

  const slingshotPos = {x: 80, y: H - 140};
  const maxDragDist = 100;

  let gameState = 'aim'; // 'aim', 'flying', 'levelComplete'
  let currentLevel = 0;
  let chancesLeft = 3;

  const birdRadius = 20;
  const pigRadius = 16;
  const blockSize = 40;

  const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
  const nextLevelBtn = document.getElementById('nextLevelBtn');
  const levelText = document.getElementById('levelText');
  const chancesText = document.getElementById('chancesText');
  const restartBtn = document.getElementById('restartBtn');

  class Bird {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.r = birdRadius;
      this.vx = 0;
      this.vy = 0;
      this.launched = false;
      this.rotation = 0;
    }
    update() {
      if(this.launched) {
        this.vy += gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= friction;
        this.vy *= friction;
        this.rotation = Math.atan2(this.vy, this.vx);

        if(this.y + this.r > H - 50) {
          resetAfterMiss();
        }
        if(this.y > H + 50 || this.x < -50 || this.x > W + 50) {
          resetAfterMiss();
        }
      }
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      ctx.scale(-1, 1);

      // Body with gradient & subtle shadow
      const grad = ctx.createRadialGradient(0, 0, this.r*0.2, 0, 0, this.r);
      grad.addColorStop(0, '#ff4d4d');
      grad.addColorStop(1, '#a80000');
      ctx.fillStyle = grad;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.r, this.r*0.75, 0, 0, Math.PI*2);
      ctx.fill();

      // White eye with subtle shadow
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 3;
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.ellipse(-6, -5, 6, 8, 0, 0, Math.PI*2);
      ctx.fill();

      // Pupil with gloss effect
      ctx.shadowColor = 'transparent';
      ctx.beginPath();
      ctx.fillStyle = 'black';
      ctx.ellipse(-5, -3, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.ellipse(-4, -5, 1.5, 2, 0, 0, Math.PI*2);
      ctx.fill();

      // Beak with gradient and slight shadow
      ctx.shadowColor = 'rgba(0,0,0,0.2)';
      ctx.shadowBlur = 2;
      ctx.beginPath();
      ctx.fillStyle = 'orange';
      ctx.moveTo(this.r, 0);
      ctx.lineTo(this.r + 18, -10);
      ctx.lineTo(this.r + 18, 10);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  }

  class Block {
    constructor(x,y,w,h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.health = 3;
      this.isStatic = true;
      this.angle = 0;
      this.rotationSpeed = 0;
    }
    update() {}
    draw() {
      ctx.save();
      ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.rotate(this.angle);

      // Wood grain gradient
      let grad = ctx.createLinearGradient(-this.w/2, 0, this.w/2, 0);
      grad.addColorStop(0, '#deb887');
      grad.addColorStop(0.5, '#a0522d');
      grad.addColorStop(1, '#8b4513');
      ctx.fillStyle = grad;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 5;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);

      // Wood grain lines
      ctx.shadowColor = 'transparent';
      ctx.strokeStyle = '#5a3318cc';
      ctx.lineWidth = 2;
      for(let i = -this.h/2 + 5; i < this.h/2; i += 8) {
        ctx.beginPath();
        ctx.moveTo(-this.w/2, i);
        ctx.lineTo(this.w/2, i+1);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  class Pig {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.r = pigRadius;
      this.alive = true;
    }
    draw() {
      if(!this.alive) return;
      ctx.save();
      ctx.translate(this.x, this.y);

      // Green body gradient with shadow
      const grad = ctx.createRadialGradient(0, 0, this.r*0.2, 0, 0, this.r);
      grad.addColorStop(0, '#7ed57e');
      grad.addColorStop(1, '#276227');
      ctx.fillStyle = grad;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.r, this.r*0.85, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.shadowColor = 'transparent';
      // Ears
      ctx.fillStyle = '#4caf50';
      ctx.beginPath();
      ctx.ellipse(-10, -15, 7, 9, Math.PI/5, 0, Math.PI*2);
      ctx.ellipse(10, -15, 7, 9, -Math.PI/5, 0, Math.PI*2);
      ctx.fill();

      // Eyes whites
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.ellipse(-7, -5, 5, 6, 0, 0, Math.PI*2);
      ctx.ellipse(7, -5, 5, 6, 0, 0, Math.PI*2);
      ctx.fill();

      // Pupils
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.ellipse(-7, -5, 2, 3, 0, 0, Math.PI*2);
      ctx.ellipse(7, -5, 2, 3, 0, 0, Math.PI*2);
      ctx.fill();

      // Eye highlights
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.beginPath();
      ctx.ellipse(-6, -6, 1.7, 2.2, 0, 0, Math.PI*2);
      ctx.ellipse(8, -6, 1.7, 2.2, 0, 0, Math.PI*2);
      ctx.fill();

      // Snout & nose
      ctx.fillStyle = '#388e3c';
      ctx.beginPath();
      ctx.ellipse(0, 5, 8, 4, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#2e7d32';
      ctx.beginPath();
      ctx.ellipse(-3, 5, 2, 2, 0, 0, Math.PI*2);
      ctx.ellipse(3, 5, 2, 2, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  // Function to generate level blocks and pigs
  // Level num is zero-based index; pigs count = level + 1
  function generateLevel(levelNum) {
    const blocks = [];
    const pigs = [];

    // Block arrangement changes every level for variety
    // Blocks form walls, towers, platforms randomly but deterministic

    const baseX = 230;
    const baseY = H - 90;
    const blockW = blockSize;
    const blockH = blockSize;

    // Different patterns per level
    switch(levelNum) {
      case 0:
        // Level 1: simple 3 blocks line with 1 pig on top center
        blocks.push({x: baseX, y: baseY, w: blockW, h: blockH});
        blocks.push({x: baseX + blockW, y: baseY, w: blockW, h: blockH});
        blocks.push({x: baseX + 2*blockW, y: baseY, w: blockW, h: blockH});
        pigs.push({x: baseX + blockW + blockW/2, y: baseY - 40});
        break;
      case 1:
        // Level 2: 5 blocks platform, 2 pigs on top
        for(let i=0; i<5; i++) {
          blocks.push({x: baseX - 20 + i*blockW, y: baseY, w: blockW, h: blockH});
        }
        pigs.push({x: baseX + blockW/2, y: baseY - 40});
        pigs.push({x: baseX + 3*blockW, y: baseY - 40});
        break;
      case 2:
        // Level 3: 2 columns, 3 pigs on top
        blocks.push({x: baseX, y: baseY, w: blockW, h: blockH});
        blocks.push({x: baseX + 3*blockW, y: baseY, w: blockW, h: blockH});
        blocks.push({x: baseX, y: baseY - blockH, w: blockW, h: blockH});
        blocks.push({x: baseX + 3*blockW, y: baseY - blockH, w: blockW, h: blockH});
        pigs.push({x: baseX + 10, y: baseY - 80});
        pigs.push({x: baseX + blockW + 10, y: baseY - 80});
        pigs.push({x: baseX + 3*blockW + 10, y: baseY - 80});
        break;
      case 3:
        // Level 4: square base with pig cluster inside (4 pigs)
        for(let i=0; i<3; i++) {
          blocks.push({x: baseX + i*blockW, y: baseY, w: blockW, h: blockH});
          blocks.push({x: baseX + i*blockW, y: baseY - 2*blockH, w: blockW, h: blockH});
        }
        blocks.push({x: baseX, y: baseY - blockH, w: blockW, h: blockH});
        blocks.push({x: baseX + 2*blockW, y: baseY - blockH, w: blockW, h: blockH});
        for(let i=0; i<2; i++) {
          for(let j=0; j<2; j++) {
            pigs.push({x: baseX + blockW/2 + i*blockW, y: baseY - blockH - 40 + j*10});
          }
        }
        break;
      case 4:
        // Level 5: tall tower 5 blocks, 5 pigs at different heights
        for(let i=0; i<5; i++) {
          blocks.push({x: baseX + blockW, y: baseY - i*blockH, w: blockW, h: blockH});
          pigs.push({x: baseX + blockW + 10, y: baseY - i*blockH - 40});
        }
        break;
      case 5:
        // Level 6: pyramid shape, 6 pigs on levels
        for(let i=0; i<3; i++) {
          for(let j=0; j<=i; j++) {
            blocks.push({x: baseX + j*blockW + (2-i)*blockW/2, y: baseY - i*blockH, w: blockW, h: blockH});
          }
        }
        for(let i=0; i<6; i++) {
          pigs.push({x: baseX + (i%3)*blockW + 10 + (2-Math.floor(i/3))*blockW/2, y: baseY - Math.floor(i/3)*blockH - 40});
        }
        break;
      case 6:
        // Level 7: scattered blocks, 7 pigs on ground or low platforms
        for(let i=0; i<5; i++) {
          blocks.push({x: baseX + i*blockW, y: baseY, w: blockW, h: blockH});
        }
        blocks.push({x: baseX + 2*blockW, y: baseY - blockH*2, w: blockW, h: blockH});
        for(let i=0; i<7; i++) {
          pigs.push({x: baseX + i*blockW*0.7 + 10, y: baseY - (i%2)*blockH - 40});
        }
        break;
      case 7:
        // Level 8: rectangle wall with hollow middle (8 pigs inside)
        for(let i=0; i<5; i++) {
          blocks.push({x: baseX + i*blockW, y: baseY, w: blockW, h: blockH});
          blocks.push({x: baseX + i*blockW, y: baseY - 3*blockH, w: blockW, h: blockH});
        }
        for(let i=1; i<3; i++) {
          blocks.push({x: baseX, y: baseY - i*blockH, w: blockW, h: blockH});
          blocks.push({x: baseX + 4*blockW, y: baseY - i*blockH, w: blockW, h: blockH});
        }
        for(let i=0; i<8; i++) {
          pigs.push({x: baseX + blockW + (i%4)*blockW, y: baseY - blockH - Math.floor(i/4)*blockH - 40});
        }
        break;
      case 8:
        // Level 9: 2 towers and bridge, 9 pigs on and around
        for(let i=0; i<5; i++) {
          blocks.push({x: baseX, y: baseY - i*blockH, w: blockW, h: blockH});
          blocks.push({x: baseX + 4*blockW, y: baseY - i*blockH, w: blockW, h: blockH});
        }
        for(let i=1; i<4; i++) {
          blocks.push({x: baseX + i*blockW, y: baseY - 2*blockH, w: blockW, h: blockH});
        }
        for(let i=0; i<9; i++) {
          pigs.push({x: baseX + (i%5)*blockW, y: baseY - (i%3)*blockH - 40});
        }
        break;
      case 9:
        // Level 10: complex structure with 10 pigs spread out
        for(let i=0; i<6; i++) {
          blocks.push({x: baseX + i*blockW, y: baseY, w: blockW, h: blockH});
          if(i<4) blocks.push({x: baseX + i*blockW + blockW/2, y: baseY - blockH*2, w: blockW, h: blockH});
        }
        blocks.push({x: baseX + 6*blockW, y: baseY - blockH, w: blockW, h: blockH});
        for(let i=0; i<10; i++) {
          pigs.push({x: baseX + (i%5)*blockW + 10, y: baseY - Math.floor(i/5)*blockH - 40});
        }
        break;
      default:
        // fallback simple layout
        blocks.push({x: baseX, y: baseY, w: blockW, h: blockH});
        pigs.push({x: baseX + blockW/2, y: baseY - 40});
    }
    return {blocks, pigs};
  }

  let bird;
  let blocks = [];
  let pigs = [];

  // Utility distance function
  function dist(x1,y1,x2,y2) {
    return Math.hypot(x1 - x2, y1 - y2);
  }

  // Collision circle-rect (bird vs block) - blocks don't fall but can be hit (optional)
  function circleRectColliding(circle, rect) {
    let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
    let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
    let distanceX = circle.x - closestX;
    let distanceY = circle.y - closestY;
    return (distanceX * distanceX + distanceY * distanceY) < (circle.r * circle.r);
  }

  // Collision circle-circle (bird vs pig)
  function circleCircleColliding(c1, c2) {
    let dx = c1.x - c2.x;
    let dy = c1.y - c2.y;
    let distance = Math.sqrt(dx*dx + dy*dy);
    return distance < (c1.r + c2.r);
  }

  function resetBird() {
    bird = new Bird(slingshotPos.x, slingshotPos.y);
    gameState = 'aim';
  }

  function saveProgress() {
    localStorage.setItem('angryBirdsLevel', currentLevel);
  }
  function loadProgress() {
    const saved = localStorage.getItem('angryBirdsLevel');
    if(saved !== null) {
      currentLevel = Math.min(parseInt(saved), 9);
    } else {
      currentLevel = 0;
    }
  }

  function loadLevel(levelIndex) {
    if(levelIndex >= 10) {
      alert('üéâ You completed all 10 levels! Refresh to play again.');
      currentLevel = 0;
      chancesLeft = 3;
      saveProgress();
      updateUI();
      resetBird();
      hideLevelComplete();
      return;
    }
    currentLevel = levelIndex;
    chancesLeft = 3;
    const lvl = generateLevel(currentLevel);
    blocks = lvl.blocks.map(b => new Block(b.x, b.y, b.w, b.h));
    pigs = lvl.pigs.map(p => new Pig(p.x, p.y));
    resetBird();
    updateUI();
    hideLevelComplete();
  }

  function updateUI() {
    levelText.textContent = `Level ${currentLevel + 1}: Knock down all pigs üê∑!`;
    chancesText.textContent = `Chances left: ${chancesLeft}`;
  }

  function resetAfterMiss() {
    chancesLeft--;
    updateUI();
    if(chancesLeft <= 0) {
      alert('No chances left! Restarting level...');
      loadLevel(currentLevel);
    } else {
      resetBird();
    }
  }

  // Check collisions bird with pigs and blocks
  function checkCollisions() {
    if(!bird.launched) return;

    // Pigs
    for(let pig of pigs) {
      if(pig.alive && circleCircleColliding(bird, pig)) {
        pig.alive = false;
      }
    }
  }

  function checkLevelClear() {
    return pigs.every(pig => !pig.alive);
  }

  // Draw slingshot base and bands
  function drawSlingshot() {
    // Base
    ctx.fillStyle = '#7b4f24';
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.fillRect(slingshotPos.x - 10, slingshotPos.y, 20, 80);

    // Bands
    if(dragging) {
      ctx.strokeStyle = '#321a00';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(slingshotPos.x - 12, slingshotPos.y + 10);
      ctx.lineTo(dragPos.x, dragPos.y);
      ctx.lineTo(slingshotPos.x + 12, slingshotPos.y + 10);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#321a00';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(slingshotPos.x - 12, slingshotPos.y + 10);
      ctx.lineTo(slingshotPos.x, slingshotPos.y + 10);
      ctx.lineTo(slingshotPos.x + 12, slingshotPos.y + 10);
      ctx.stroke();
    }
  }

  let dragging = false;
  let dragPos = {x: 0, y:0};

  function limitDrag(pos) {
    let dx = pos.x - slingshotPos.x;
    let dy = pos.y - slingshotPos.y;
    let distDrag = Math.min(Math.hypot(dx, dy), maxDragDist);
    let angle = Math.atan2(dy, dx);
    return {
      x: slingshotPos.x + distDrag * Math.cos(angle),
      y: slingshotPos.y + distDrag * Math.sin(angle)
    };
  }

  canvas.addEventListener('pointerdown', e => {
    if(gameState !== 'aim') return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if(dist(mx, my, bird.x, bird.y) < bird.r + 10) {
      dragging = true;
      dragPos.x = mx;
      dragPos.y = my;
    }
  });

  canvas.addEventListener('pointermove', e => {
    if(!dragging) return;
    const rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left;
    let my = e.clientY - rect.top;
    dragPos = limitDrag({x: mx, y: my});
    bird.x = dragPos.x;
    bird.y = dragPos.y;
  });

  canvas.addEventListener('pointerup', e => {
    if(!dragging) return;
    dragging = false;

    // Velocity is opposite drag direction
    let vx = (slingshotPos.x - bird.x);
    let vy = (slingshotPos.y - bird.y);

    // Medium speed factor for better aiming
    const speedFactor = 0.4;
    bird.vx = vx * speedFactor;
    bird.vy = vy * speedFactor;

    bird.launched = true;
    gameState = 'flying';
  });

  restartBtn.addEventListener('click', () => {
    loadLevel(currentLevel);
  });

  nextLevelBtn.addEventListener('click', () => {
    hideLevelComplete();
    loadLevel(currentLevel + 1);
  });

  function drawTrajectoryLine() {
    if(!dragging) return;
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(slingshotPos.x, slingshotPos.y);
    ctx.lineTo(bird.x, bird.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function showLevelComplete() {
    levelCompleteOverlay.classList.add('visible');
    gameState = 'levelComplete';
  }
  function hideLevelComplete() {
    levelCompleteOverlay.classList.remove('visible');
    if(gameState === 'levelComplete') {
      gameState = 'aim';
    }
  }

  function update() {
    ctx.clearRect(0, 0, W, H);

    // Draw sky gradient
    let skyGrad = ctx.createLinearGradient(0, 0, 0, H);
    skyGrad.addColorStop(0, '#a3d9ff');
    skyGrad.addColorStop(1, '#d4f0ff');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H);

    // Draw ground
    ctx.fillStyle = '#5e4426';
    ctx.fillRect(0, H - 50, W, 50);

    drawSlingshot();

    // Draw blocks (static)
    for(let block of blocks) {
      block.draw();
    }

    // Update and draw bird
    bird.update();
    bird.draw();

    // Draw pigs only if alive
    for(let pig of pigs) {
      pig.draw();
    }

    checkCollisions();

    if(gameState === 'flying' && checkLevelClear()) {
      showLevelComplete();
      saveProgress();
      return; // Pause update until next level clicked
    }

    drawTrajectoryLine();

    requestAnimationFrame(update);
  }

  // Load saved progress or start fresh
  loadProgress();
  loadLevel(currentLevel);
  updateUI();
  update();

})();
</script>

</body>
</html>
