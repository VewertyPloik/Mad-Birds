<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Mini Angry Birds - Working Drag & Launch</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    background: linear-gradient(to top, #87ceeb 0%, #fff 100%);
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: #a3d9ff;
    border-radius: 12px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.25);
    touch-action: none;
  }
  #ui {
    position: fixed;
    top: 10px; left: 10px; right: 10px;
    text-align: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #222;
    font-weight: bold;
    z-index: 10;
    user-select: none;
  }
  #restartBtn {
    background: #ff4136;
    border: none;
    border-radius: 8px;
    padding: 8px 16px;
    color: white;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    margin-top: 10px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
  }
  #restartBtn:hover {
    background: #ff6b5f;
  }
</style>
</head>
<body>

<div id="ui">
  <div id="levelText">Level 1: Knock down all pigs üê∑!</div>
  <button id="restartBtn">Restart Level</button>
</div>

<canvas id="gameCanvas" width="375" height="667"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const gravity = 0.8;
  const friction = 0.98;

  const slingshotPos = {x: 80, y: H - 140};
  const maxDragDist = 100;

  let gameState = 'aim'; // 'aim', 'flying', 'reset', 'win'
  let currentLevel = 0;

  const birdRadius = 20;
  const pigRadius = 16;
  const blockSize = 40;

  class Bird {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.r = birdRadius;
      this.vx = 0;
      this.vy = 0;
      this.launched = false;
      this.rotation = 0;
    }
    update() {
      if(this.launched) {
        this.vy += gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= friction;
        this.vy *= friction;
        this.rotation = Math.atan2(this.vy, this.vx);

        // Off screen reset
        if(this.y > H + 50 || this.x < -50 || this.x > W + 50) {
          gameState = 'reset';
        }
      }
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      ctx.scale(-1, 1); // mirror bird facing left

      // body gradient
      const grad = ctx.createRadialGradient(0, 0, this.r*0.2, 0, 0, this.r);
      grad.addColorStop(0, '#ff6666');
      grad.addColorStop(1, '#b20000');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.r, this.r*0.75, 0, 0, Math.PI*2);
      ctx.fill();

      // eye white
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.ellipse(-6, -5, 6, 8, 0, 0, Math.PI*2);
      ctx.fill();

      // pupil
      ctx.beginPath();
      ctx.fillStyle = 'black';
      ctx.ellipse(-5, -3, 3, 4, 0, 0, Math.PI*2);
      ctx.fill();

      // beak
      ctx.beginPath();
      ctx.fillStyle = 'orange';
      ctx.moveTo(this.r, 0);
      ctx.lineTo(this.r + 15, -8);
      ctx.lineTo(this.r + 15, 8);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  }

  class Block {
    constructor(x,y,w,h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.vx = 0;
      this.vy = 0;
      this.isStatic = false;
      this.angle = 0;
      this.rotationSpeed = 0;
      this.health = 3;
    }
    update() {
      if(!this.isStatic) {
        this.vy += gravity;
        this.x += this.vx;
        this.y += this.vy;

        // Simple friction / bounce on ground
        if(this.y + this.h > H - 50) {
          this.y = H - 50 - this.h;
          this.vy = -this.vy * 0.3;
          this.vx *= 0.6;
          if(Math.abs(this.vy) < 1) this.vy = 0;
        }

        this.vx *= 0.7;
        this.vy *= 0.7;

        this.angle += this.rotationSpeed;
        this.rotationSpeed *= 0.7;

        if(this.health <= 0) this.isStatic = true;
      }
    }
    draw() {
      ctx.save();
      ctx.translate(this.x + this.w/2, this.y + this.h/2);
      ctx.rotate(this.angle);

      // wood gradient
      let grad = ctx.createLinearGradient(-this.w/2, 0, this.w/2, 0);
      grad.addColorStop(0, '#d2b48c');
      grad.addColorStop(0.5, '#a97457');
      grad.addColorStop(1, '#6f4e37');
      ctx.fillStyle = grad;
      ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);

      // grain lines
      ctx.strokeStyle = '#4b2e0a88';
      ctx.lineWidth = 2;
      for(let i = -this.h/2 + 5; i < this.h/2; i += 10) {
        ctx.beginPath();
        ctx.moveTo(-this.w/2, i);
        ctx.lineTo(this.w/2, i+2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  class Pig {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.r = pigRadius;
      this.alive = true;
    }
    draw() {
      if(!this.alive) return;
      ctx.save();
      ctx.translate(this.x, this.y);

      const grad = ctx.createRadialGradient(0, 0, this.r*0.2, 0, 0, this.r);
      grad.addColorStop(0, '#81c784');
      grad.addColorStop(1, '#2e7d32');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.r, this.r*0.85, 0, 0, Math.PI*2);
      ctx.fill();

      // ears
      ctx.fillStyle = '#4caf50';
      ctx.beginPath();
      ctx.ellipse(-10, -15, 7, 9, Math.PI/5, 0, Math.PI*2);
      ctx.ellipse(10, -15, 7, 9, -Math.PI/5, 0, Math.PI*2);
      ctx.fill();

      // eyes
      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.ellipse(-7, -5, 5, 6, 0, 0, Math.PI*2);
      ctx.ellipse(7, -5, 5, 6, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = 'black';
      ctx.ellipse(-7, -5, 2, 3, 0, 0, Math.PI*2);
      ctx.ellipse(7, -5, 2, 3, 0, 0, Math.PI*2);
      ctx.fill();

      // nose
      ctx.fillStyle = '#388e3c';
      ctx.beginPath();
      ctx.ellipse(0, 5, 8, 4, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#2e7d32';
      ctx.beginPath();
      ctx.ellipse(-3, 5, 2, 2, 0, 0, Math.PI*2);
      ctx.ellipse(3, 5, 2, 2, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  // Levels: blocks and pigs positions
  const levels = [
    {
      blocks: [
        {x: 250, y: H - 90, w: blockSize, h: blockSize},
        {x: 290, y: H - 90, w: blockSize, h: blockSize},
        {x: 270, y: H - 130, w: blockSize, h: blockSize},
      ],
      pigs: [
        {x: 280, y: H - 160},
        {x: 320, y: H - 130},
      ],
    },
    {
      blocks: [
        {x: 230, y: H - 90, w: blockSize, h: blockSize},
        {x: 270, y: H - 90, w: blockSize, h: blockSize},
        {x: 310, y: H - 90, w: blockSize, h: blockSize},
        {x: 250, y: H - 130, w: blockSize, h: blockSize},
        {x: 290, y: H - 130, w: blockSize, h: blockSize},
        {x: 270, y: H - 170, w: blockSize, h: blockSize},
      ],
      pigs: [
        {x: 260, y: H - 160},
        {x: 320, y: H - 160},
        {x: 280, y: H - 200},
      ],
    },
    {
      blocks: [
        {x: 250, y: H - 90, w: blockSize, h: blockSize},
        {x: 250, y: H - 130, w: blockSize, h: blockSize},
        {x: 250, y: H - 170, w: blockSize, h: blockSize},
        {x: 290, y: H - 90, w: blockSize, h: blockSize},
        {x: 290, y: H - 130, w: blockSize, h: blockSize},
        {x: 330, y: H - 90, w: blockSize, h: blockSize},
        {x: 330, y: H - 130, w: blockSize, h: blockSize},
        {x: 290, y: H - 170, w: blockSize, h: blockSize},
      ],
      pigs: [
        {x: 270, y: H - 210},
        {x: 310, y: H - 210},
        {x: 300, y: H - 250},
        {x: 270, y: H - 150},
      ],
    }
  ];

  let bird, blocks, pigs;

  // Utility distance
  function dist(x1,y1,x2,y2){
    return Math.hypot(x2 - x1, y2 - y1);
  }

  // Collision between circle and rect
  function circleRectColliding(circle, rect) {
    let distX = Math.abs(circle.x - rect.x - rect.w/2);
    let distY = Math.abs(circle.y - rect.y - rect.h/2);

    if(distX > (rect.w/2 + circle.r)) return false;
    if(distY > (rect.h/2 + circle.r)) return false;

    if(distX <= (rect.w/2)) return true;
    if(distY <= (rect.h/2)) return true;

    let dx = distX - rect.w/2;
    let dy = distY - rect.h/2;
    return (dx*dx + dy*dy <= (circle.r*circle.r));
  }

  // Load current level
  function loadLevel(n){
    const lvl = levels[n];
    bird = new Bird(slingshotPos.x, slingshotPos.y);
    blocks = lvl.blocks.map(b => {
      let block = new Block(b.x, b.y, b.w, b.h);
      return block;
    });
    pigs = lvl.pigs.map(p => new Pig(p.x, p.y));
    gameState = 'aim';
    aimPos.x = slingshotPos.x;
    aimPos.y = slingshotPos.y;
    aiming = false;
    updateLevelText();
  }

  // Update level text
  function updateLevelText(){
    const el = document.getElementById('levelText');
    el.textContent = `Level ${currentLevel + 1}: Knock down all pigs üê∑!`;
  }

  // Collision checks
  function handleCollisions(){
    // Bird - blocks
    for(let block of blocks) {
      if(block.isStatic) continue;
      if(circleRectColliding(bird, block)) {
        // Bounce bird
        bird.vx = -bird.vx * 0.6;
        bird.vy = -bird.vy * 0.6;

        // Block reacts
        block.vx += bird.vx * 0.3;
        block.vy += bird.vy * 0.3;
        block.rotationSpeed += (bird.vx + bird.vy) * 0.05;

        block.health -= 1;
        if(block.health <= 0) {
          block.isStatic = true;
        }
      }
    }

    // Bird - pigs
    for(let pig of pigs) {
      if(!pig.alive) continue;
      let d = dist(bird.x, bird.y, pig.x, pig.y);
      if(d < bird.r + pig.r) {
        pig.alive = false;
        // Slow bird down a bit
        bird.vx *= 0.7;
        bird.vy *= 0.7;
      }
    }

    // Block - pigs (block hitting pig kills pig)
    for(let pig of pigs) {
      if(!pig.alive) continue;
      for(let block of blocks) {
        if(block.isStatic) continue;
        let d = dist(pig.x, pig.y, block.x + block.w/2, block.y + block.h/2);
        if(d < pig.r + Math.max(block.w, block.h)/2) {
          pig.alive = false;
        }
      }
    }
  }

  // Aim related vars
  let aiming = false;
  let aimPos = {x: slingshotPos.x, y: slingshotPos.y};

  // Handle pointer events (works for mouse and touch)
  function getPointerPos(evt) {
    const rect = canvas.getBoundingClientRect();
    if(evt.touches) {
      return {
        x: evt.touches[0].clientX - rect.left,
        y: evt.touches[0].clientY - rect.top,
      };
    } else {
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top,
      };
    }
  }

  canvas.addEventListener('pointerdown', evt => {
    if(gameState !== 'aim') return;
    const pos = getPointerPos(evt);
    if(dist(pos.x, pos.y, bird.x, bird.y) < bird.r + 20) {
      aiming = true;
    }
  });

  canvas.addEventListener('pointermove', evt => {
    if(!aiming) return;
    const pos = getPointerPos(evt);
    let dx = pos.x - slingshotPos.x;
    let dy = pos.y - slingshotPos.y;
    let dragDist = Math.min(Math.hypot(dx, dy), maxDragDist);
    let angle = Math.atan2(dy, dx);

    aimPos.x = slingshotPos.x + Math.cos(angle) * dragDist;
    aimPos.y = slingshotPos.y + Math.sin(angle) * dragDist;

    bird.x = aimPos.x;
    bird.y = aimPos.y;
  });

  canvas.addEventListener('pointerup', evt => {
    if(!aiming) return;
    aiming = false;
    let dx = aimPos.x - slingshotPos.x;
    let dy = aimPos.y - slingshotPos.y;

    bird.vx = -dx * 0.2;
    bird.vy = -dy * 0.2;
    bird.launched = true;
    gameState = 'flying';
  });

  // Restart button
  document.getElementById('restartBtn').addEventListener('click', () => {
    loadLevel(currentLevel);
  });

  function drawSlingshotBase() {
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#553311';
    ctx.beginPath();
    ctx.moveTo(slingshotPos.x - 20, slingshotPos.y + 40);
    ctx.lineTo(slingshotPos.x + 20, slingshotPos.y + 40);
    ctx.stroke();

    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(slingshotPos.x, slingshotPos.y);
    ctx.lineTo(slingshotPos.x - 15, slingshotPos.y + 40);
    ctx.lineTo(slingshotPos.x + 15, slingshotPos.y + 40);
    ctx.closePath();
    ctx.fillStyle = '#6b3e0e';
    ctx.fill();
  }

  function drawElasticLine() {
    if(aiming) {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(slingshotPos.x, slingshotPos.y);
      ctx.lineTo(bird.x, bird.y);
      ctx.stroke();
    }
  }

  function drawGround() {
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, H - 50, W, 50);
  }

  function checkWin() {
    if(pigs.every(p => !p.alive)) {
      gameState = 'win';
    }
  }

  function nextLevel() {
    currentLevel++;
    if(currentLevel >= levels.length) {
      alert('You completed all levels! üéâ');
      currentLevel = 0;
    }
    loadLevel(currentLevel);
  }

  function update() {
    if(gameState === 'reset') {
      loadLevel(currentLevel);
    }
    if(gameState === 'win') {
      // Wait 1 sec then next level
      setTimeout(() => nextLevel(), 1000);
      gameState = 'waiting';
    }

    if(gameState === 'flying') {
      bird.update();
      blocks.forEach(b => b.update());
      handleCollisions();
      checkWin();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);
    drawGround();
    blocks.forEach(b => b.draw());
    pigs.forEach(p => p.draw());
    bird.draw();
    drawSlingshotBase();
    drawElasticLine();
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  loadLevel(currentLevel);
  loop();
})();
</script>

</body>
</html>
